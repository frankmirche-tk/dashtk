<?php

declare(strict_types=1);

namespace App\Command;

use Symfony\Component\Console\Attribute\AsCommand;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\ArrayInput;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Style\SymfonyStyle;

/**
 * DocsReportCommand
 *
 * Purpose:
 * - Builds a small "docs package" by orchestrating existing documentation/usage commands and
 *   writing their outputs into a target directory (default: var/docs).
 *
 * What it generates:
 * - services.{md|json}
 *   - generated by: dashtk:docs:services
 * - usage_report.{md|json}
 *   - generated by: dashtk:usage:report
 *
 * AI cost integration:
 * - Variant 1 ("Cost is part of usage report"):
 *   - dashtk:usage:report includes AI cost KPIs + deltas (rolling daily/7/30).
 *   - Therefore, we do NOT generate a separate ai_cost_report_* by default anymore.
 *
 * Optional AI cost detail report:
 * - If --with-ai-cost-detail is enabled, we also generate:
 *   - ai_cost_report_YYYY-MM-DD_HH-MM-SS.{md|json}
 *   - generated by: dashtk:ai:cost:report
 *
 * Timestamped snapshots:
 * - If --stamp is enabled, output filenames include a timestamp suffix:
 *   - services_YYYY-MM-DD_HH-MM-SS.{md|json}
 *   - usage_report_YYYY-MM-DD_HH-MM-SS.{md|json}
 *   - (optional) ai_cost_report_YYYY-MM-DD_HH-MM-SS.{md|json}
 *
 * Passthrough design:
 * - services-* options -> dashtk:docs:services
 * - usage-* options -> dashtk:usage:report
 * - ai-cost-* options -> dashtk:ai:cost:report (only if --with-ai-cost-detail)
 *
 * Compatibility note (important!):
 * - We want to pass a rolling window selection to dashtk:usage:report.
 * - Depending on your current implementation state, the nested usage command might expose:
 *   - (new) --period / --day
 *   - OR (older) --usage-period / --usage-day
 * - This wrapper detects which options exist on the nested command and maps accordingly.
 */
#[AsCommand(
    name: 'dashtk:docs:report',
    description: 'Erzeugt ein Doku-Paket (services + usage_report) in var/docs/.'
)]
final class DocsReportCommand extends Command
{
    protected function configure(): void
    {
        $this
            // core output behavior
            ->addOption('dir', null, InputOption::VALUE_REQUIRED, 'Zielordner (Standard: var/docs)', 'var/docs')
            ->addOption('stamp', null, InputOption::VALUE_NONE, 'Schreibt timestamped Dateien, z.B. services_YYYY-MM-DD_HH-MM-SS.md')
            ->addOption('format', null, InputOption::VALUE_REQUIRED, 'Format der Dateien: md|json (Standard: md)', 'md')

            // services.md options passthrough
            ->addOption('services-namespace', null, InputOption::VALUE_REQUIRED, 'Namespace-Prefix für das Service-Scanning', 'App\\Service\\')
            ->addOption('services-with-usage', null, InputOption::VALUE_NONE, 'Services-Doku: zeigt TrackUsage + Usage/Impact, falls vorhanden')
            ->addOption('services-only-tracked', null, InputOption::VALUE_NONE, 'Services-Doku: zeigt nur Methoden mit #[TrackUsage(...)]')

            // usage_report.md options passthrough
            ->addOption('usage-namespace', null, InputOption::VALUE_REQUIRED, 'Namespace-Prefix für den Usage-Report', 'App\\Service\\')
            ->addOption('top', null, InputOption::VALUE_REQUIRED, 'Usage-Report: Top N (Standard: 20)', '20')
            ->addOption('low', null, InputOption::VALUE_REQUIRED, 'Usage-Report: Low usage Schwelle (<= low). Standard: 2', '2')
            ->addOption('unused', null, InputOption::VALUE_REQUIRED, 'Usage-Report: Unused Schwelle (<= unused). Standard: 0', '0')
            ->addOption('critical', null, InputOption::VALUE_REQUIRED, 'Usage-Report: Critical weight threshold (>= critical). Standard: 7', '7')
            ->addOption('attention-weight', null, InputOption::VALUE_REQUIRED, 'Usage-Report: Attention weight threshold (>= attention-weight). Standard: 5', '5')
            ->addOption('min-impact', null, InputOption::VALUE_REQUIRED, 'Usage-Report: Filter impact >= min-impact (Standard: 0)', '0')

            /**
             * AI Cost rolling window selection for usage_report (Variant 1):
             * - Exposed as prefixed options on this wrapper, to keep wrapper stable.
             * - Internally we map these values to the nested usage command, depending on which
             *   option names it exposes (period/day vs usage-period/usage-day).
             */
            ->addOption('usage-period', null, InputOption::VALUE_REQUIRED, 'Usage-Report: daily|weekly|monthly (rolling AI cost window). Default: daily', 'daily')
            ->addOption('usage-day', null, InputOption::VALUE_REQUIRED, 'Usage-Report: End day YYYY-MM-DD (rolling AI cost window). Default: heute', date('Y-m-d'))

            /**
             * Optional: Write separate AI cost detail report as a third artifact.
             * - Default OFF because Variant 1 already embeds cost in usage_report.
             */
            ->addOption('with-ai-cost-detail', null, InputOption::VALUE_NONE, 'Schreibt zusätzlich ai_cost_report_* als Detail-Report (optional)')
            ->addOption('ai-cost-day', null, InputOption::VALUE_REQUIRED, 'AI Cost Detail: Tag (YYYY-MM-DD). Default: heute', date('Y-m-d'))
            ->addOption('ai-cost-top', null, InputOption::VALUE_REQUIRED, 'AI Cost Detail: Top N Kostentreiber (Default: 20)', '20');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);

        $dir    = rtrim((string) $input->getOption('dir'), '/');
        $stamp  = (bool) $input->getOption('stamp');
        $format = strtolower((string) $input->getOption('format'));

        if ($format !== 'md' && $format !== 'json') {
            $format = 'md';
        }

        if (!is_dir($dir)) {
            @mkdir($dir, 0777, true);
        }

        // filename base
        $suffix = $stamp ? ('_' . date('Y-m-d_H-i-s')) : '';
        $ext = $format;

        $servicesOut = sprintf('%s/services%s.%s', $dir, $suffix, $ext);
        $usageOut    = sprintf('%s/usage_report%s.%s', $dir, $suffix, $ext);

        // Optional detail report output
        $withAiCostDetail = (bool) $input->getOption('with-ai-cost-detail');
        $aiCostOut = sprintf('%s/ai_cost_report%s.%s', $dir, $suffix, $ext);

        // 1) Run: dashtk:docs:services
        $servicesArgs = [
            'command' => 'dashtk:docs:services',
            'namespace' => (string) $input->getOption('services-namespace'),
            '--format' => $format,
            '--output' => $servicesOut,
        ];
        if ((bool) $input->getOption('services-with-usage')) {
            $servicesArgs['--with-usage'] = true;
        }
        if ((bool) $input->getOption('services-only-tracked')) {
            $servicesArgs['--only-tracked'] = true;
        }

        $servicesCode = $this->runCommand($output, $servicesArgs);
        if ($servicesCode !== Command::SUCCESS) {
            $io->error('Fehler beim Erzeugen von services.*');
            return $servicesCode;
        }

        // 2) Run: dashtk:usage:report (Variant 1: includes AI cost within usage report)
        $usagePeriod = strtolower((string) $input->getOption('usage-period'));
        if (!in_array($usagePeriod, ['daily', 'weekly', 'monthly'], true)) {
            $usagePeriod = 'daily';
        }

        $usageDay = (string) $input->getOption('usage-day');
        if (!preg_match('/^\d{4}-\d{2}-\d{2}$/', $usageDay)) {
            $usageDay = date('Y-m-d');
        }

        // Base args (always supported)
        $usageArgs = [
            'command' => 'dashtk:usage:report',
            '--namespace' => (string) $input->getOption('usage-namespace'),
            '--format' => $format,
            '--output' => $usageOut,

            '--top' => (string) $input->getOption('top'),
            '--low' => (string) $input->getOption('low'),
            '--unused' => (string) $input->getOption('unused'),
            '--critical' => (string) $input->getOption('critical'),
            '--attention-weight' => (string) $input->getOption('attention-weight'),
            '--min-impact' => (string) $input->getOption('min-impact'),
        ];

        /**
         * Rolling window mapping:
         * - NEW style (recommended): nested usage report exposes --period / --day
         * - Legacy style: nested usage report exposes --usage-period / --usage-day
         *
         * We detect which options exist to prevent runtime CLI errors.
         */
        $usageCmd = $this->findCommand('dashtk:usage:report');
        if ($usageCmd === null) {
            $io->error('Nested command not found: dashtk:usage:report');
            return Command::FAILURE;
        }

        if ($this->commandHasOption($usageCmd, 'period')) {
            $usageArgs['--period'] = $usagePeriod;
        } elseif ($this->commandHasOption($usageCmd, 'usage-period')) {
            $usageArgs['--usage-period'] = $usagePeriod;
        }

        if ($this->commandHasOption($usageCmd, 'day')) {
            $usageArgs['--day'] = $usageDay;
        } elseif ($this->commandHasOption($usageCmd, 'usage-day')) {
            $usageArgs['--usage-day'] = $usageDay;
        }

        $usageCode = $this->runKnownCommand($usageCmd, $usageArgs, $output);
        if ($usageCode !== Command::SUCCESS) {
            $io->error('Fehler beim Erzeugen von usage_report.*');
            return $usageCode;
        }

        // 3) Optional: write separate AI cost detail report (debug / finance drill-down)
        if ($withAiCostDetail) {
            $aiDay = (string) $input->getOption('ai-cost-day');
            if (!preg_match('/^\d{4}-\d{2}-\d{2}$/', $aiDay)) {
                $aiDay = date('Y-m-d');
            }

            $aiTop = max(1, (int) $input->getOption('ai-cost-top'));

            $aiArgs = [
                'command' => 'dashtk:ai:cost:report',
                '--day' => $aiDay,
                '--format' => $format,
                '--output' => $aiCostOut,
                '--top' => (string) $aiTop,
            ];

            $aiCode = $this->runCommand($output, $aiArgs);
            if ($aiCode !== Command::SUCCESS) {
                $io->error('Fehler beim Erzeugen von ai_cost_report.* (Detail).');
                return $aiCode;
            }
        }

        // Success output: show exactly what was written
        if ($withAiCostDetail) {
            $io->success("OK Doku-Paket geschrieben:\n  - {$servicesOut}\n  - {$usageOut}\n  - {$aiCostOut}");
        } else {
            $io->success("OK Doku-Paket geschrieben:\n  - {$servicesOut}\n  - {$usageOut}");
        }

        return Command::SUCCESS;
    }

    /**
     * Find a Symfony Console command by name within the current application.
     *
     * @param string $name Command name.
     *
     * @return Command|null Command instance or null if application not available.
     */
    private function findCommand(string $name): ?Command
    {
        $app = $this->getApplication();
        if ($app === null) {
            return null;
        }

        return $app->has($name) ? $app->find($name) : null;
    }

    /**
     * Check whether a given command defines an option with the provided name.
     *
     * This prevents runtime errors like:
     * "The \"--period\" option does not exist."
     *
     * @param Command $cmd  Command to inspect.
     * @param string  $name Option name without leading dashes (e.g. "period").
     */
    private function commandHasOption(Command $cmd, string $name): bool
    {
        return $cmd->getDefinition()->hasOption($name);
    }

    /**
     * Run another Symfony Console command inside the same application.
     *
     * Implementation details:
     * - Finds the referenced command by name.
     * - Executes the nested command using ArrayInput.
     * - Uses NullOutput to keep routine output clean, because nested commands write to files.
     *
     * @param OutputInterface      $output Outer output (only used for fatal errors).
     * @param array<string, mixed> $args   Command name + arguments/options for the nested command.
     */
    private function runCommand(OutputInterface $output, array $args): int
    {
        $app = $this->getApplication();
        if ($app === null) {
            $output->writeln('<error>Console application not available.</error>');
            return Command::FAILURE;
        }

        $cmdName = (string) ($args['command'] ?? '');
        if ($cmdName === '') {
            $output->writeln('<error>Missing command name.</error>');
            return Command::FAILURE;
        }

        $cmd = $app->find($cmdName);

        // Keep output quiet from nested runs (they write to files anyway).
        $nestedOutput = new \Symfony\Component\Console\Output\NullOutput();

        return $cmd->run(new ArrayInput($args), $nestedOutput);
    }

    /**
     * Run a command instance that we already resolved (avoids double-find and allows option introspection).
     *
     * @param Command         $cmd    Resolved command instance.
     * @param array<string,mixed> $args   Command args/options.
     * @param OutputInterface $output Outer output (only used for fatal errors).
     */
    private function runKnownCommand(Command $cmd, array $args, OutputInterface $output): int
    {
        $nestedOutput = new \Symfony\Component\Console\Output\NullOutput();
        return $cmd->run(new ArrayInput($args), $nestedOutput);
    }
}
