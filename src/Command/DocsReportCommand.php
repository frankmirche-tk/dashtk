<?php

declare(strict_types=1);

namespace App\Command;

use Symfony\Component\Console\Attribute\AsCommand;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\ArrayInput;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Style\SymfonyStyle;

/**
 * DocsReportCommand
 *
 * Purpose:
 * - Builds a small "docs package" by orchestrating existing documentation/usage commands and
 *   writing their outputs into a target directory (default: var/docs).
 *
 * What it generates:
 * - services.{md|json}
 *   - generated by: dashtk:docs:services
 * - usage_report.{md|json}
 *   - generated by: dashtk:usage:report
 *
 * Timestamped snapshots:
 * - If --stamp is enabled, output filenames include a timestamp suffix:
 *   - services_YYYY-MM-DD_HH-MM-SS.{md|json}
 *   - usage_report_YYYY-MM-DD_HH-MM-SS.{md|json}
 * - This is intended for recurring jobs and historical comparisons (e.g. daily/weekly/monthly runs).
 *
 * Passthrough design:
 * - This command does not implement documentation logic itself.
 * - It forwards ("passthrough") options to the underlying commands so the report content can be tuned
 *   without duplicating logic:
 *   - services-* options -> dashtk:docs:services
 *   - usage-* + thresholds -> dashtk:usage:report
 *
 * Output behavior:
 * - Nested commands are executed with NullOutput (quiet), because their output is written to files.
 * - This command prints only a high-level success/error summary to STDOUT (suitable for cron logs).
 *
 * Error handling:
 * - Fails fast:
 *   - if services generation fails -> exits immediately
 *   - if usage report generation fails -> exits immediately
 * - On success, prints the two written file paths.
 *
 * Typical usage:
 * - One-off:
 *   - php bin/console dashtk:docs:report
 * - Timestamped snapshot:
 *   - php bin/console dashtk:docs:report --stamp
 * - JSON output:
 *   - php bin/console dashtk:docs:report --format=json
 * - With usage enrichment in services doc:
 *   - php bin/console dashtk:docs:report --services-with-usage
 *
 * Notes:
 * - This command assumes the following commands exist in the same application:
 *   - dashtk:docs:services
 *   - dashtk:usage:report
 * - Directory creation is best-effort (mkdir) to keep cron runs robust.
 */
#[AsCommand(
    name: 'dashtk:docs:report',
    description: 'Erzeugt ein Doku-Paket (services + usage_report) in var/docs/.'
)]
final class DocsReportCommand extends Command
{
    /**
     * Configure output options and passthrough parameters for underlying commands.
     *
     * Core output behavior:
     * - dir: target folder
     * - stamp: enable timestamped filenames
     * - format: md|json
     *
     * Passthrough:
     * - services-* options control dashtk:docs:services
     * - usage-* options control dashtk:usage:report
     */
    protected function configure(): void
    {
        $this
            // core output behavior
            ->addOption('dir', null, InputOption::VALUE_REQUIRED, 'Zielordner (Standard: var/docs)', 'var/docs')
            ->addOption('stamp', null, InputOption::VALUE_NONE, 'Schreibt timestamped Dateien, z.B. services_YYYY-MM-DD_HH-MM-SS.md')
            ->addOption('format', null, InputOption::VALUE_REQUIRED, 'Format der Dateien: md|json (Standard: md)', 'md')

            // services.md options passthrough
            ->addOption('services-namespace', null, InputOption::VALUE_REQUIRED, 'Namespace-Prefix für das Service-Scanning', 'App\\Service\\')
            ->addOption('services-with-usage', null, InputOption::VALUE_NONE, 'Services-Doku: zeigt TrackUsage + Usage/Impact, falls vorhanden')
            ->addOption('services-only-tracked', null, InputOption::VALUE_NONE, 'Services-Doku: zeigt nur Methoden mit #[TrackUsage(...)]')

            // usage_report.md options passthrough
            ->addOption('usage-namespace', null, InputOption::VALUE_REQUIRED, 'Namespace-Prefix für den Usage-Report', 'App\\Service\\')
            ->addOption('top', null, InputOption::VALUE_REQUIRED, 'Usage-Report: Top N (Standard: 20)', '20')
            ->addOption('low', null, InputOption::VALUE_REQUIRED, 'Usage-Report: Low usage Schwelle (<= low). Standard: 2', '2')
            ->addOption('unused', null, InputOption::VALUE_REQUIRED, 'Usage-Report: Unused Schwelle (<= unused). Standard: 0', '0')
            ->addOption('critical', null, InputOption::VALUE_REQUIRED, 'Usage-Report: Critical weight threshold (>= critical). Standard: 7', '7')
            ->addOption('attention-weight', null, InputOption::VALUE_REQUIRED, 'Usage-Report: Attention weight threshold (>= attention-weight). Standard: 5', '5')
            ->addOption('min-impact', null, InputOption::VALUE_REQUIRED, 'Usage-Report: Filter impact >= min-impact (Standard: 0)', '0');
    }

    /**
     * Execute the docs package generation.
     *
     * Steps:
     * 1) Resolve target directory and output file names (optional timestamp suffix).
     * 2) Run dashtk:docs:services with --output pointing to services.{ext}.
     * 3) Run dashtk:usage:report with --output pointing to usage_report.{ext}.
     * 4) Print a success message with the created file paths.
     *
     * @param InputInterface  $input  CLI input.
     * @param OutputInterface $output CLI output.
     *
     * @return int Command::SUCCESS on success, otherwise the failing nested command's exit code.
     */
    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);

        $dir    = rtrim((string) $input->getOption('dir'), '/');
        $stamp  = (bool) $input->getOption('stamp');
        $format = strtolower((string) $input->getOption('format'));

        if ($format !== 'md' && $format !== 'json') {
            $format = 'md';
        }

        if (!is_dir($dir)) {
            @mkdir($dir, 0777, true);
        }

        // filename base
        $suffix = $stamp ? ('_' . date('Y-m-d_H-i-s')) : '';
        $ext = $format;

        $servicesOut = sprintf('%s/services%s.%s', $dir, $suffix, $ext);
        $usageOut    = sprintf('%s/usage_report%s.%s', $dir, $suffix, $ext);

        // 1) Run: dashtk:docs:services
        $servicesArgs = [
            'command' => 'dashtk:docs:services',
            'namespace' => (string) $input->getOption('services-namespace'),
            '--format' => $format,
            '--output' => $servicesOut,
        ];
        if ((bool) $input->getOption('services-with-usage')) {
            $servicesArgs['--with-usage'] = true;
        }
        if ((bool) $input->getOption('services-only-tracked')) {
            $servicesArgs['--only-tracked'] = true;
        }

        $servicesCode = $this->runCommand($output, $servicesArgs);
        if ($servicesCode !== Command::SUCCESS) {
            $io->error('Fehler beim Erzeugen von services.*');
            return $servicesCode;
        }

        // 2) Run: dashtk:usage:report
        $usageArgs = [
            'command' => 'dashtk:usage:report',
            '--namespace' => (string) $input->getOption('usage-namespace'),
            '--format' => $format,
            '--output' => $usageOut,

            '--top' => (string) $input->getOption('top'),
            '--low' => (string) $input->getOption('low'),
            '--unused' => (string) $input->getOption('unused'),
            '--critical' => (string) $input->getOption('critical'),
            '--attention-weight' => (string) $input->getOption('attention-weight'),
            '--min-impact' => (string) $input->getOption('min-impact'),
        ];

        $usageCode = $this->runCommand($output, $usageArgs);
        if ($usageCode !== Command::SUCCESS) {
            $io->error('Fehler beim Erzeugen von usage_report.*');
            return $usageCode;
        }

        $io->success("OK Doku-Paket geschrieben:\n  - {$servicesOut}\n  - {$usageOut}");
        return Command::SUCCESS;
    }

    /**
     * Run another Symfony Console command inside the same application.
     *
     * Implementation details:
     * - Retrieves the current Console Application instance and finds the referenced command by name.
     * - Executes the nested command using ArrayInput.
     * - Uses NullOutput to keep the routine output clean, because nested commands typically write to files.
     *
     * @param OutputInterface        $output Outer output (only used for fatal errors).
     * @param array<string, mixed>   $args   Command name + arguments/options for the nested command.
     *
     * @return int Exit code of the nested command (Command::SUCCESS or Command::FAILURE).
     */
    private function runCommand(OutputInterface $output, array $args): int
    {
        $app = $this->getApplication();
        if ($app === null) {
            $output->writeln('<error>Console application not available.</error>');
            return Command::FAILURE;
        }

        $cmdName = (string) ($args['command'] ?? '');
        if ($cmdName === '') {
            $output->writeln('<error>Missing command name.</error>');
            return Command::FAILURE;
        }

        $cmd = $app->find($cmdName);

        // Keep output quiet from nested runs (they write to files anyway).
        $nestedOutput = new \Symfony\Component\Console\Output\NullOutput();

        return $cmd->run(new ArrayInput($args), $nestedOutput);
    }
}
